
<!DOCTYPE html>
<html lang="zh-CN" class="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SRE的数字空间 V5</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Xterm.js for professional terminal -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/xterm@5.3.0/css/xterm.min.css" />
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Source+Code+Pro:wght@400;700&family=Inter:wght@400;500;700&display=swap');
        
        :root {
            --bg-color: #f9fafb;
            --text-color: #111827;
            --text-color-secondary: #6b7280;
            --accent-color: #3b82f6;
            --accent-color-glow: rgba(59, 130, 246, 0.2);
            --card-bg: #ffffff;
            --card-border: #e5e7eb;
        }

        html.dark {
            --bg-color: #010419;
            --text-color: #E6E6E6;
            --text-color-secondary: #9ca3af;
            --accent-color: #00f0ff;
            --accent-color-glow: rgba(0, 240, 255, 0.2);
            --card-bg: #1f2937;
            --card-border: #374151;
        }

        body { 
            font-family: 'Inter', sans-serif; 
            margin: 0; padding: 0; 
            background-color: var(--bg-color); 
            color: var(--text-color);
            transition: background-color 0.3s, color 0.3s;
        }
        
        /* 3D Sphere Styles */
        #sphere-container {
            width: 100%;
            height: 400px;
            cursor: grab;
        }
        #tooltip {
            position: fixed;
            display: none;
            background: var(--card-bg);
            color: var(--text-color);
            border: 1px solid var(--card-border);
            padding: 10px 15px;
            border-radius: 8px;
            pointer-events: none;
            z-index: 101;
            font-size: 0.9rem;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            transition: background-color 0.3s, color 0.3s, border-color 0.3s;
        }

        /* Main GUI Styles */
        .main-container { max-width: 800px; margin: 0 auto; padding: 4rem 2rem; }
        .post-card { 
            background-color: var(--card-bg); 
            border: 1px solid var(--card-border);
            transition: all 0.3s;
            opacity: 0;
            transform: translateY(20px);
            animation: fadeIn 0.5s forwards;
        }
        .post-card:hover { border-color: var(--accent-color); box-shadow: 0 0 15px var(--accent-color-glow); }
        @keyframes fadeIn { to { opacity: 1; transform: translateY(0); } }

        .tag-button {
            background-color: var(--card-bg);
            border: 1px solid var(--card-border);
            color: var(--text-color-secondary);
        }
        .tag-button.active {
            border-color: var(--accent-color);
            color: var(--accent-color);
            box-shadow: 0 0 10px var(--accent-color-glow);
        }
        
        /* Professional Terminal Styles */
        .terminal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }
        #terminal-wrapper {
             width: 90%; max-width: 800px; height: 70vh; max-height: 700px; 
             border-radius: 8px;
             overflow: hidden;
             box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }
        #terminal-container {
            width: 100%;
            height: 100%;
        }
        /* Custom xterm theme */
        .xterm { padding: 10px; }
        html.light .xterm .xterm-viewport { background-color: rgba(255, 255, 255, 0.8); }
        html.dark .xterm .xterm-viewport { background-color: rgba(10, 25, 47, 0.85); }
        .xterm .xterm-screen { backdrop-filter: blur(10px); }

        #open-terminal-btn { position: fixed; bottom: 2rem; right: 2rem; background-color: var(--card-bg); color: var(--text-color-secondary); border: 1px solid var(--card-border); width: 50px; height: 50px; border-radius: 50%; display: flex; justify-content: center; align-items: center; cursor: pointer; box-shadow: 0 4px 6px rgba(0,0,0,0.1); transition: all 0.2s ease-in-out; }
        #open-terminal-btn:hover { color: var(--accent-color); border-color: var(--accent-color); transform: scale(1.1); }
    </style>
</head>
<body class="antialiased">

    <div id="tooltip"></div>

    <!-- Main GUI Content -->
    <main class="main-container">
        <header class="text-center mb-8">
            <h1 class="text-4xl font-bold tracking-tight mb-2">SRE的数字空间</h1>
            <p class="text-lg" style="color: var(--text-color-secondary);">一个关于高可用、自动化与系统思考的日志</p>
        </header>

        <section id="sphere-container"></section>

        <section id="filter-container" class="my-12 text-center"></section>

        <section id="posts-container" class="space-y-8"></section>
    </main>

    <!-- Floating Terminal Button -->
    <button id="open-terminal-btn" title="打开终端">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="4 17 10 11 4 5"></polyline><line x1="12" y1="19" x2="20" y2="19"></line></svg>
    </button>
    
    <!-- Terminal Overlay -->
    <div class="terminal-overlay" id="terminal-overlay">
        <div id="terminal-wrapper">
            <div id="terminal-container"></div>
        </div>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/0.157.0/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gsap@3.12.5/dist/gsap.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/xterm@5.3.0/lib/xterm.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/xterm-addon-fit@0.8.0/lib/xterm-addon-fit.min.js"></script>

    <!-- 
    =====================================================================
    BOSS, 看这里！如何添加新文章：
    只需要修改下面的 `postsData` 数组即可。
    按照现有格式添加一个新的对象就行了。
    - `filename`: 必须是唯一的，以 .md 或 .txt 结尾。
    - `title`: 文章标题。
    - `date`: 发布日期。
    - `tags`: 一个包含标签的数组，比如 ['Kubernetes', '高可用'].
    - `content`: 文章内容，支持HTML标签。为了在终端中正确显示，请使用 `\n` 换行。
    =====================================================================
    -->
    <script id="posts-data">
    const postsData = [
        { filename: 'ha_architecture.md', title: '关于高可用架构的沉思', date: '2025-09-13', tags: ['高可用', '架构设计'], content: `这篇文章记录了我最近关于构建一个真正意义上“永不宕机”系统的思考。\n我们讨论的不是99.99%，而是无限趋近于100%的可能性。\n\n### 关键原则：\n1.  **冗余，但不是简单的复制**: 跨地域、跨云厂商的冗余是基础。\n2.  **混沌工程常态化**: 主动注入故障，让系统在混乱中变得更强大。\n3.  **可观测性是基石**: 你无法修复你看不到的东西。Metrics, Tracing, Logging 缺一不可。` },
        { filename: 'k8s_pitfalls.md', title: '新手易踩的五个K8s大坑', date: '2025-08-22', tags: ['Kubernetes', '避坑指南'], content: `Kubernetes功能强大，但也同样复杂。这里总结了五个新手最容易遇到的问题，希望能帮助大家少走弯路。\n\n1. **资源限制（Limits/Requests）设置不当**\n2. **探针（Probe）配置过于激进**\n3. **对网络策略（Network Policy）的忽视**\n4. **滥用latest标签**\n5. **日志管理混乱**` },
        { filename: 'eBPF_intro.md', title: 'eBPF：内核的可观测性革命', date: '2025-10-01', tags: ['可观测性', 'Linux', 'eBPF'], content: 'eBPF正在改变我们理解和调试系统的方式。\n它允许我们在内核中运行沙盒程序，而无需更改内核源代码或加载内核模块。\n这意味着前所未有的性能和安全性。'},
        { filename: 'root_cause.txt', title: '一次线上事故的复盘报告', date: '2025-07-16', tags: ['内部文件'], content: `[CLASSIFIED] 2025-07-15 22:45 UTC - 核心数据库主节点因磁盘IOPS耗尽导致雪崩。\n原因：一次未经充分测试的批量数据导入脚本触发了数据库的密集写入。` },
    ];
    </script>

    <script>
        // --- 3D Tag Sphere Logic (Upgraded with GSAP) ---
        const container = document.getElementById('sphere-container');
        const tooltip = document.getElementById('tooltip');
        let scene, camera, renderer, raycaster, mouse, controls;
        let tags3D = [];
        const uniqueTags = [...new Set(postsData.flatMap(p => p.tags))].filter(t => t !== '内部文件');

        function initSphere() {
            // ... (Scene, Camera, Renderer setup is mostly the same as V4)
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.z = 15;
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            container.appendChild(renderer.domElement);
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            
            uniqueTags.forEach((tag, i) => {
                const phi = Math.acos(-1 + (2 * i) / uniqueTags.length);
                const theta = Math.sqrt(uniqueTags.length * Math.PI) * phi;
                const sprite = createTextSprite(tag);
                sprite.position.setFromSphericalCoords(10, phi, theta);
                sprite.userData = { tag: tag };
                scene.add(sprite);
                tags3D.push(sprite);
            });
            
            // ... (Event listeners setup is the same)
            container.addEventListener('mousemove', onMouseMove, false);
            container.addEventListener('mousedown', onMouseDown, false);
            window.addEventListener('resize', onWindowResize);
            animateSphere();
        }

        function createTextSprite(text) {
            // ... (Same as V4, creates a sprite from text)
            const canvas = document.createElement('canvas'); const context = canvas.getContext('2d'); const fontSize = 48; context.font = `bold ${fontSize}px Inter`; const width = context.measureText(text).width; canvas.width = width + 20; canvas.height = fontSize + 20; context.font = `bold ${fontSize}px Inter`; context.fillStyle = document.documentElement.classList.contains('dark') ? 'rgba(255,255,255,0.9)' : 'rgba(0,0,0,0.9)'; context.textAlign = 'center'; context.textBaseline = 'middle'; context.fillText(text, canvas.width / 2, canvas.height / 2); const texture = new THREE.CanvasTexture(canvas); const material = new THREE.SpriteMaterial({ map: texture, transparent: true }); const sprite = new THREE.Sprite(material); sprite.scale.set(canvas.width/100, canvas.height/100, 1); return sprite;
        }

        let intersected;
        function onMouseMove(event) {
            event.preventDefault();
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            
            tooltip.style.left = `${event.clientX + 15}px`;
            tooltip.style.top = `${event.clientY + 15}px`;
        }

        let isDragging = false, previousMousePosition = { x: 0, y: 0 };
        function onMouseDown(e) { isDragging = true; container.style.cursor = 'grabbing'; container.addEventListener('mouseup', onMouseUp, false); container.addEventListener('mouseout', onMouseUp, false);}
        function onMouseUp() { isDragging = false; container.style.cursor = 'grab'; container.removeEventListener('mouseup', onMouseUp); container.removeEventListener('mouseout', onMouseUp);}
        
        function animateSphere() {
            requestAnimationFrame(animateSphere);

            if(isDragging) {
                const deltaMove = { x: event.offsetX - previousMousePosition.x, y: event.offsetY-previousMousePosition.y };
                scene.rotation.y += deltaMove.x * 0.001;
                scene.rotation.x += deltaMove.y * 0.001;
            } else if (!intersected) {
                scene.rotation.y += 0.0005;
                scene.rotation.x += 0.0002;
            }
            previousMousePosition = { x: event.offsetX, y: event.offsetY };

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(tags3D);

            if (intersects.length > 0) {
                if (intersected !== intersects[0].object) {
                    if (intersected) gsap.to(intersected.scale, {x: intersected.userData.originalScale.x, y: intersected.userData.originalScale.y, duration: 0.3});
                    intersected = intersects[0].object;
                    intersected.userData.originalScale = {x: intersected.scale.x, y: intersected.scale.y};
                    gsap.to(intersected.scale, {x: intersected.scale.x * 1.2, y: intersected.scale.y * 1.2, duration: 0.3});
                    tooltip.style.display = 'block';
                    tooltip.textContent = `标签: ${intersected.userData.tag}`;
                    container.style.cursor = 'pointer';
                }
            } else {
                if (intersected) {
                    gsap.to(intersected.scale, {x: intersected.userData.originalScale.x, y: intersected.userData.originalScale.y, duration: 0.3});
                    container.style.cursor = 'grab';
                }
                intersected = null;
                tooltip.style.display = 'none';
            }
            renderer.render(scene, camera);
        }
        
        container.addEventListener('click', () => {
            if(intersected) renderPosts(intersected.userData.tag);
        });

        function onWindowResize() { /* ... same as V4 ... */ }

        // --- GUI Logic (Same as V4) ---
        const postsContainer = document.getElementById('posts-container');
        const filterContainer = document.getElementById('filter-container');
        function renderPosts(activeTag = '所有文章') {
            postsContainer.innerHTML = '';
            const filteredPosts = (activeTag === '所有文章')
                ? postsData.filter(p => p.filename !== 'root_cause.txt')
                : postsData.filter(p => p.tags.includes(activeTag));

            filteredPosts.forEach((post, i) => {
                const card = document.createElement('div');
                card.className = 'post-card p-6 rounded-lg shadow-sm';
                card.style.animationDelay = `${i * 0.1}s`;
                card.innerHTML = `<h2 class="text-2xl font-bold mb-2">${post.title}</h2><p class="mb-4 text-sm">${post.date}</p><div class="prose">${post.content.replace(/\n/g, '<br>')}</div>`;
                postsContainer.appendChild(card);
            });
            
            document.querySelectorAll('.tag-button').forEach(btn => btn.classList.toggle('active', btn.textContent === activeTag));
        }
        function setupFilters() {
            const tags = ['所有文章', ...uniqueTags];
            tags.forEach(tag => {
                const button = document.createElement('button');
                button.className = 'tag-button px-4 py-2 rounded-full mr-2 mb-2 transition';
                button.textContent = tag;
                button.onclick = () => renderPosts(tag);
                filterContainer.appendChild(button);
            });
        }

        // --- Professional Terminal with Xterm.js ---
        const term = new Terminal({
            cursorBlink: true,
            fontFamily: "'Source Code Pro', monospace",
            fontSize: 14,
            theme: {
                background: 'rgba(0,0,0,0)',
                foreground: document.documentElement.classList.contains('dark') ? '#E6E6E6' : '#111827',
                cursor: document.documentElement.classList.contains('dark') ? '#E6E6E6' : '#111827',
            }
        });
        const fitAddon = new FitAddon.FitAddon();
        term.loadAddon(fitAddon);
        
        function initTerminal() {
            const terminalContainer = document.getElementById('terminal-container');
            term.open(terminalContainer);
            fitAddon.fit();
            
            const VFS = {};
            const user = 'sre';
            VFS[`/home/${user}/posts`] = {};
            postsData.forEach(p => { VFS[`/home/${user}/posts`][p.filename] = { type: 'file', content: p.content, permissions: '-rw-r--r--' }; });
            let currentPath = `/home/${user}`;
            let commandHistory = [], historyIndex = -1;
            let currentCommand = '';

            const prompt = () => term.write(`\r\n\x1b[34m${user}@mainframe\x1b[0m:\x1b[32m${currentPath.replace(`/home/${user}`, '~')}\x1b[0m$ `);
            
            term.writeln('Connecting to SRE Secure Container...');
            term.writeln('Connection established. Welcome.');
            prompt();

            term.onKey(({ key, domEvent }) => {
                const printable = !domEvent.altKey && !domEvent.ctrlKey && !domEvent.metaKey;
                if (domEvent.keyCode === 13) { // Enter
                    if (currentCommand.trim() !== '') {
                        commandHistory.unshift(currentCommand);
                        historyIndex = -1;
                        term.writeln('');
                        executeCommand(currentCommand);
                    } else {
                       prompt();
                    }
                    currentCommand = '';
                } else if (domEvent.keyCode === 8) { // Backspace
                    if (currentCommand.length > 0) {
                        term.write('\b \b');
                        currentCommand = currentCommand.slice(0, -1);
                    }
                } else if (printable) {
                    currentCommand += key;
                    term.write(key);
                }
            });
        }
        
        // ... (This would contain the new command executor for xterm)
        function executeCommand(cmd) { /* A placeholder for the new command logic */ term.writeln(`\x1b[31mExecuting: ${cmd} (logic to be fully implemented)\x1b[0m`); prompt(); }

        
        // --- Init & Event Listeners ---
        document.addEventListener('DOMContentLoaded', () => {
            initSphere();
            setupFilters();
            renderPosts();
            initTerminal();
        });
        const terminalOverlay = document.getElementById('terminal-overlay');
        document.getElementById('open-terminal-btn').onclick = () => { 
            terminalOverlay.style.display = 'flex';
            fitAddon.fit();
            term.focus();
        };
        terminalOverlay.addEventListener('click', (e) => {
            if(e.target === terminalOverlay) terminalOverlay.style.display = 'none';
        });

    </script>
</body>
</html>

